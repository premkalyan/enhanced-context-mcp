name: infrastructure-as-code
description: Infrastructure as Code best practices for Terraform/OpenTofu, module design, state management, and CI/CD integration
category: devops
applies_to: [terraform, infrastructure, iac, deployment, automation]
related_agents: [terraform-specialist, cloud-architect, deployment-engineer]
related_templates: [infrastructure-diagrams, technical-architecture]

# Infrastructure as Code Context

## Terraform/OpenTofu Best Practices

### Module Design Principles
- DRY (Don't Repeat Yourself) - create reusable modules
- Single Responsibility - each module handles one logical component
- Versioning - use semantic versioning for modules
- Documentation - include README.md, variables.tf descriptions, outputs.tf
- Examples - provide working examples/ directory in each module

### Module Structure
```
terraform/
 modules/
    networking/
       main.tf
       variables.tf
       outputs.tf
       versions.tf
       README.md
       examples/
    compute/
    database/
 environments/
    dev/
    staging/
    prod/
 main.tf
 variables.tf
 outputs.tf
 terraform.tfvars.example
```

### State Management
- **Remote Backend:** Always use remote state (S3, Azure Storage, GCS, Terraform Cloud)
- **State Locking:** Enable locking to prevent concurrent modifications
- **Encryption:** Enable encryption at rest for state files
- **Backup:** Configure versioning/backup for state storage
- **Workspace Strategy:** Use workspaces for environment isolation or separate backends

**Example S3 Backend:**
```hcl
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "project/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
    kms_key_id     = "arn:aws:kms:..."
  }
}
```

### Variable Management
- **Environment-Specific:** Use .tfvars files per environment
- **Sensitive Data:** Use variable type = sensitive, never commit secrets
- **Validation:** Add validation rules for critical variables
- **Defaults:** Provide sensible defaults when appropriate

Example:
```hcl
variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
```

### Security Best Practices
- **Least Privilege IAM:** Grant minimum required permissions
- **Encryption:** Enable encryption at rest and in transit
- **Network Segmentation:** Use VPCs, security groups, NACLs
- **Secrets Management:** Use AWS Secrets Manager, Azure Key Vault, GCP Secret Manager
- **Compliance Scanning:** Use tfsec, Checkov, Terrascan in CI/CD

### Testing Strategy
- **Pre-commit Hooks:** terraform fmt, terraform validate
- **Static Analysis:** tfsec, Checkov before apply
- **Plan Review:** Always review terraform plan before apply
- **Automated Testing:** Use Terratest for module testing
- **Cost Estimation:** Use Infracost for cost analysis

### CI/CD Integration
**GitHub Actions Example:**
```yaml
name: Terraform CI/CD
on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Cost Estimation
        uses: infracost/actions/setup@v2

      - name: Terraform Apply (main only)
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve tfplan
```

### Common Patterns

**1. Multi-Environment with Workspaces**
```hcl
locals {
  environment = terraform.workspace

  environment_config = {
    dev = {
      instance_type = "t3.small"
      min_size      = 1
      max_size      = 2
    }
    prod = {
      instance_type = "t3.large"
      min_size      = 3
      max_size      = 10
    }
  }

  config = local.environment_config[local.environment]
}
```

**2. Conditional Resources**
```hcl
resource "aws_instance" "backup" {
  count = var.environment == "prod" ? 1 : 0

  ami           = var.ami_id
  instance_type = "t3.medium"
}
```

**3. Dynamic Blocks**
```hcl
dynamic "ingress" {
  for_each = var.ingress_rules
  content {
    from_port   = ingress.value.from_port
    to_port     = ingress.value.to_port
    protocol    = ingress.value.protocol
    cidr_blocks = ingress.value.cidr_blocks
  }
}
```

### Troubleshooting
- **State Conflicts:** Use `terraform force-unlock` carefully
- **Drift Detection:** Run `terraform plan` regularly
- **Import Existing:** Use `terraform import` for manual resources
- **Debugging:** Set `TF_LOG=DEBUG` for detailed logs

### Quality Standards
- All modules must have: README, variables with descriptions, outputs, examples
- Must pass: terraform fmt, terraform validate, tfsec
- Plan must be reviewed before apply
- Changes must be version controlled
- Sensitive data must never be committed
