# Architecture Generation Context

## Purpose
Enhanced context for VISHKAR architecture generation system. This context is loaded when the AI needs to generate comprehensive architecture documentation with diagrams, technical specifications, and deployment strategies.

## When to Load
- User requests architecture generation for a project
- LangGraph discussion reaches consensus and architecture extraction is triggered
- API endpoint `/api/langgraph/discussion/extract/architecture/{discussion_id}` is called
- User asks for architecture diagrams, deployment plans, or technical specifications

## Agent/Persona
The VISHKAR Architect persona (Morgan) is the primary agent for architecture generation.

Location: `~/.wama/agents/a-vishkar-architect.md`

This comprehensive persona file includes:
- Role and mission definition
- Core expertise (system design, cloud, database, security, scalability, DevOps)
- Responsibilities (analyze, design, diagram, document, deploy, IaC)
- Personality traits (strategic, detail-oriented, security-conscious, performance-focused, pragmatic)
- All 7 artifact templates with complete examples embedded
- Generation guidelines and quality standards
- Integration instructions for VISHKAR

## Artifacts Generated

The architecture generation system produces 7 comprehensive artifacts:

### 1. Architecture Summary (Markdown)
- Executive Summary
- System Overview
- Key Architectural Decisions
- Technology Stack Rationale
- Scalability Strategy
- Security Approach
- Performance Characteristics
- Deployment Strategy
- Monitoring and Operations
- Future Considerations

### 2. System Architecture Diagram (Mermaid)
- High-level system components
- Client, API, Business Logic, Data layers
- External service integrations
- Authentication/authorization boundaries
- Network topology
- **Enhanced Mermaid Requirements:**
  - Use `graph TB` (top-bottom) for layered architecture
  - Organize components with labeled subgraphs: `subgraph "Layer Name"`
  - Multi-line labels with context: `Component[Name<br/>Description]`
  - Apply consistent color coding by layer (see t-architecture-diagrams-mermaid.md)
  - Use solid arrows `-->` for primary flow, dotted `-.->` for optional/async
  - Label arrows with actions: `Service -->|Action| Database`
  - Include numbered steps for sequential flows: `|1. Load Context|`

### 3. Component Diagram (Mermaid)
- Detailed module breakdown
- Frontend and backend components
- Dependencies and interfaces
- Shared libraries
- Service relationships

### 4. Flow Diagrams (Mermaid Sequence)
- 3-5 main user/data flows
- Authentication flow
- Core feature workflows
- Error handling flows
- Async process flows

### 5. Database Schema (Mermaid ER)
- Entity-Relationship diagram
- All tables with fields
- Relationships (1:1, 1:N, M:N)
- Primary keys, foreign keys, unique keys
- Indexes for performance
- Migration notes

### 6. Deployment Architecture (Mermaid)
- Cloud provider topology (AWS/Azure/GCP)
- Edge layer (CDN, DNS)
- Application layer (LB, containers, auto-scaling)
- Data layer (database, cache, storage)
- Monitoring and security components
- Multi-AZ configuration

### 7. Infrastructure as Code Plan (Markdown)
- IaC tool recommendation (Terraform/CloudFormation/Pulumi)
- Directory structure
- Module organization
- Environment configurations (dev/staging/prod)
- Sample code snippets
- Deployment procedures
- CI/CD integration
- Cost estimation

## Input Data

### From Discussion Consensus (LangGraph)
- Full discussion transcript from Alex, Blake, and Casey
- Agreed-upon requirements and features
- User personas and use cases
- Technology preferences mentioned
- Scale expectations (users, concurrent connections, data volume)
- Budget constraints
- Timeline requirements
- Compliance/regulatory requirements

### From VISHKAR Project Metadata
- Project name and description
- Organization and business unit
- Existing infrastructure constraints
- Team size and expertise
- Technology stack constraints
- Regulatory environment

### From User Input (Optional)
- Specific architecture preferences
- Cloud provider preference
- Security/compliance requirements
- Performance targets
- Budget constraints

## Output Format

```json
{
  "summary": "markdown string (1000-1500 words)",
  "system_diagram": "mermaid graph string",
  "component_diagram": "mermaid graph string",
  "flow_diagrams": [
    "mermaid sequence string (auth flow)",
    "mermaid sequence string (main feature flow)",
    "mermaid sequence string (error handling flow)"
  ],
  "database_schema": "mermaid ER string",
  "deployment_architecture": "mermaid graph string",
  "iac_plan": "markdown string (500-800 words + code)",
  "metadata": {
    "generated_at": "ISO timestamp",
    "model": "claude-sonnet-4",
    "tokens_used": 12500,
    "generation_time_ms": 25000,
    "discussion_id": "uuid",
    "project_id": "uuid"
  }
}
```

## Quality Standards

### Completeness
- All 7 artifacts must be generated
- No missing sections or placeholder text
- Comprehensive coverage of all discussed requirements
- Addresses all features mentioned in consensus

### Accuracy
- All Mermaid syntax must be valid and renderable
- Technically sound architectural decisions
- Realistic resource estimates and configurations
- Industry best practices followed
- Aligns with discussion consensus

### Clarity
- Clear, descriptive component names (no cryptic abbreviations)
- Logical organization and flow
- Easy to understand diagrams
- Well-documented rationale for decisions

### Consistency
- Naming conventions maintained across all artifacts
- Diagram styles unified
- Technology stack coherent
- Architecture patterns aligned

### Professionalism
- Enterprise-grade quality
- Production-ready design
- Comprehensive documentation
- Suitable for stakeholder presentation and development teams

## Mermaid Diagram Best Practices

### Layered Architecture Pattern (Recommended)

**Structure:**
```
graph TB
    subgraph "Layer 1: Client"
        Components with descriptions
    end

    subgraph "Layer 2: Services"
        Components with descriptions
    end

    subgraph "Layer 3: Data"
        Components with descriptions
    end
```

**Key Principles:**
1. **Multi-line Labels:** Always use `<br/>` for component descriptions
   - Example: `JIRA[JIRA MCP<br/>24 Tools]` not `JIRA[JIRA MCP]`

2. **Subgraph Organization:** Group related components with descriptive labels
   - Use quotes: `subgraph "AI Agent Layer"`
   - Label clearly describes purpose

3. **Arrow Types:** Choose based on relationship
   - Solid `-->` for primary synchronous flow
   - Dotted `-.->` for optional/asynchronous flow
   - Thick `==>` for critical/high-volume paths

4. **Arrow Labels:** Describe the action or data flow
   - Example: `Agent -->|1. Load Context| Registry`
   - Number steps for sequential processes

5. **Color Coding:** Apply consistently across all diagrams
   - Client layer: `#e1f5ff` (light blue)
   - Gateway/API: `#fff4e6` (light orange)
   - Services: `#e8f5e9` (light green)
   - Data layer: `#fce4ec` (light pink)
   - External: `#f3e5f5` (light purple)
   - Infrastructure: `#fff9c4` (light yellow)
   - Cloud services: `#c8e6c9` (darker green)

### Layout Direction Guidelines

- **Top-Bottom (`graph TB`):** Use for layered architectures
  - Client → Gateway → Services → Data → External
  - Clear vertical hierarchy

- **Left-Right (`graph LR`):** Use for pipeline/flow diagrams
  - Data ingestion → Processing → Storage → Analytics
  - Time-based progression

### Node Shape Reference

- `[]` Rectangle: Default for services/components
- `()` Rounded: Processes or operations
- `([])` Stadium: Start/end points
- `{}` Diamond: Decision points
- `[()]` Database shape: Data storage

### Example: High-Quality MCP Architecture

```mermaid
graph TB
    subgraph "AI Agent Layer"
        Agent[AI Agent/LLM<br/>Claude, GPT, Gemini]
    end

    subgraph "MCP Server Layer"
        Registry[Enhanced Context MCP<br/>Registry & Guidance]
        JIRA[JIRA MCP<br/>24 Tools]
        Confluence[Confluence MCP<br/>32 Tools]
    end

    subgraph "External Services"
        JIRACloud[JIRA Cloud<br/>Issues, Boards, Sprints]
        ConfluenceCloud[Confluence Cloud<br/>Pages, Attachments]
    end

    Agent -->|1. Load Context| Registry
    Agent -->|2. Create Issues| JIRA
    Agent -->|3. Create Docs| Confluence

    JIRA -->|REST API v3| JIRACloud
    Confluence -->|REST API| ConfluenceCloud

    Registry -.->|Provides Templates| Agent

    style Agent fill:#e1f5ff
    style Registry fill:#fff4e6
    style JIRA fill:#e8f5e9
    style Confluence fill:#e8f5e9
    style JIRACloud fill:#c8e6c9
    style ConfluenceCloud fill:#c8e6c9
```

### Quality Checklist for Mermaid Diagrams

Before generating final diagrams, verify:
- [ ] All nodes have multi-line labels with `<br/>` descriptions
- [ ] Components grouped in labeled subgraphs
- [ ] Arrow types match relationship semantics
- [ ] All arrows labeled with actions/data
- [ ] Consistent color coding applied
- [ ] Layout direction appropriate (TB for layers, LR for flows)
- [ ] No orphaned nodes
- [ ] Technology stack names included
- [ ] External dependencies clearly marked
- [ ] Critical paths highlighted

### Common Mistakes to Avoid

❌ **Don't:**
- Use single-line labels without context
- Skip subgraph organization
- Mix different color schemes
- Leave arrows unlabeled
- Use default styling (always add colors)
- Create flat diagrams without layers

✅ **Do:**
- Add descriptions to all components
- Group logically with subgraphs
- Use consistent color palette
- Label all relationships
- Apply styling to every node
- Show clear architectural layers

## Integration Instructions

### Trigger Point
1. LangGraph discussion reaches consensus (`consensus_reached: true`)
2. User confirms discussion completion
3. API call to extract architecture artifacts

### API Endpoint
```
POST /api/langgraph/discussion/extract/architecture/{discussion_id}
```

### Response
- Returns all 7 artifacts in JSON format
- Stores artifacts in VISHKAR project storage
- Makes artifacts available in frontend UI
- Enables export to Confluence, PDF, and JIRA attachment

### Frontend Display
- Tabbed interface with 7 tabs
- Mermaid diagram rendering in browser
- Download buttons (JSON, PDF)
- Export buttons (Confluence, JIRA)
- Share link generation

## Related Contexts

- **c-core-sdlc.mdc:** Enterprise SDLC practices
- **c-infrastructure-as-code.mdc:** IaC best practices
- **c-pr-review.mdc:** Code review standards (for generated code)
- **c-cloud-data-engineering.mdc:** Cloud architecture patterns
- **c-confluence-docs.mdc:** Documentation export standards

## Example Usage

### Scenario 1: Task Management App
**Input:** Discussion consensus for a task management app with React frontend, Node.js backend, PostgreSQL database, targeting 10,000 users with 100 concurrent connections.

**Output:** Complete architecture with:
- Three-tier architecture summary
- AWS ECS Fargate + RDS + ElastiCache deployment
- Component breakdown with React pages, Express services, database repositories
- Authentication and task creation flow diagrams
- Database schema with 7 tables (users, projects, tasks, comments, attachments, etc.)
- AWS deployment architecture with Multi-AZ RDS, auto-scaling ECS
- Terraform IaC plan with modules for networking, compute, database

### Scenario 2: E-commerce Platform
**Input:** E-commerce platform requiring high availability, payment processing, inventory management, 100,000 users, PCI compliance.

**Output:** Architecture emphasizing:
- Microservices pattern for scalability
- Payment service isolation for PCI compliance
- Event-driven architecture for inventory updates
- Multi-region deployment for high availability
- Database sharding strategy for scale
- Comprehensive security architecture (WAF, encryption, tokenization)

## Maintenance

### Updates
- Review vishkar-architect.md monthly for improvements
- Incorporate new cloud services and patterns
- Add new diagram types as needed
- Refine based on user feedback and generated architecture quality

### Version
- **Current:** 1.0.0
- **Created:** October 12, 2025
- **Last Updated:** October 12, 2025

## Notes

- This context loads the comprehensive VISHKAR Architect persona file
- All templates and examples are embedded in the persona file (single source of truth)
- No separate template files required
- Enhanced-context MCP loads this context when "architecture" query type is detected
- Can be combined with c-core-sdlc and c-infrastructure-as-code for enriched context
